#' Spanning labels to identify groups of rows or columns
#'
#' @export
#' @inheritParams tt
#' @inheritParams style_tt
#' @param indent integer number of `pt` to use when indenting the non-labelled rows.
#' @param ... All additional arguments (ex: `italic`, `bold`, `color`) are automatically passed to the `style_tt()` function and applied to the labels.
group_tt <- function(x, i, j, indent = 1, ...) {

  # sanity x
  m <- meta(x)
  if (is.null(m)) stop("`x` must be generated by `tinytable::tt()`.", call. = FALSE)
  if (!isTRUE(m$output %in% c("html", "latex"))) return(x)

  out <- x

  assert_integerish(indent, lower = 1)
  if ((missing(i) && missing(j)) || (!missing(i) && !missing(j))) {
    stop("One and only one of `i` or `j` must be specified.", call. = FALSE)
  }

  if (missing(i)) i <- NULL
  if (missing(j)) j <- NULL

  i <- sanitize_group_index(i, hi = attr(x, "nrow") + 1)
  j <- sanitize_group_index(j, hi = attr(x, "ncol"))

  # we don't need this as a list, and we use some sorting later
  i <- unlist(i)

  if (m$output == "latex") {
    out <- group_tabularray(out, i = i, j = j, indent = indent, ...)
  } else if (m$output == "html") {
    out <- group_bootstrap(out, i = i, j = j, indent = indent, ...)
  }

  if (is.list(j)) attr(out, "nhead") <- attr(out, "nhead") + 1

  return(out)
}



sanitize_group_index <- function(idx, hi) {
  if (is.null(idx)) return(idx)
  assert_list(idx, named = TRUE)
  for (n in names(idx)) {
    assert_integerish(idx[[n]], lower = 1, upper = hi, name = n)
  }
  if (anyDuplicated(unlist(idx)) > 0) stop("Duplicate group indices.", call. = FALSE)
  out <- lapply(idx, function(x) min(x):max(x))
  return(out)
}
